"use strict";(self.webpackChunkhelp=self.webpackChunkhelp||[]).push([[9087],{44338:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=n(74848),o=n(28453);const i={title:"CSRF protection"},r=void 0,a={id:"checks/CSRF-protection",title:"CSRF protection",description:"Testomato & CSRF protecion",source:"@site/docs/checks/06-CSRF-protection.md",sourceDirName:"checks",slug:"/checks/CSRF-protection",permalink:"/checks/CSRF-protection",draft:!1,unlisted:!1,editUrl:"https://github.com/testomato/help.testomato.com/edit/master/docs/checks/06-CSRF-protection.md",tags:[],version:"current",lastUpdatedAt:1644307587e3,sidebarPosition:6,frontMatter:{title:"CSRF protection"},sidebar:"docs",previous:{title:"Common Server Errors",permalink:"/checks/common-server-errors"},next:{title:"Notifications and alerts",permalink:"/checks/notifications"}},c={},l=[{value:"Testomato &amp; CSRF protecion",id:"testomato--csrf-protecion",level:2},{value:"What&#39;s CSRF protecion",id:"whats-csrf-protecion",level:2},{value:"Preventing CSRF Requests",id:"preventing-csrf-requests",level:3},{value:"Per-Form Tokens",id:"per-form-tokens",level:3},{value:"Resources",id:"resources",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"testomato--csrf-protecion",children:"Testomato & CSRF protecion"}),"\n",(0,s.jsxs)(t.p,{children:["Can Testomato hadle forms with CSRF protecion. The simply answer is NO.\nIf your application is protected from cross-site request forgery attacks, it's also\npreventing Testomato from sending requests with ",(0,s.jsx)(t.a,{href:"https://github.com/testomato/minicrawler",children:"minicralwer"}),", but we can try to\nbridge the simplest type of protection by doubling the request."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"During the first request"}),", Testomato ignores HTTP response code -\nusually there\u2019s some sort of unauthorized request response,\nbut we update all hidden form params values and save the session."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"The second request"})," is submitted within the same session in the hopes that one of the hidden params has a valid CSRF token"]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"whats-csrf-protecion",children:"What's CSRF protecion"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",children:"Cross-site request forgeries"})," are a type of malicious\nexploit where unauthorized commands are performed on behalf of an authenticated user."]}),"\n",(0,s.jsxs)(t.p,{children:["In case you're not familiar with cross-site request forgeries, let's discuss an example of how this\nvulnerability can be exploited. Imagine your application has a ",(0,s.jsx)(t.code,{children:"/user/email"})," route that accepts a\n",(0,s.jsx)(t.code,{children:"POST"})," request to change the authenticated user's email address. Most likely, this route expects\nan email input field to contain the email address the user would like to begin using."]}),"\n",(0,s.jsxs)(t.p,{children:["Without CSRF protection, a malicious website could create an HTML form that points to your\napplication's ",(0,s.jsx)(t.code,{children:"/user/email"})," route and submits the malicious user's own email address"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:'<form action="https://your-application.com/user/email" method="POST">\n  <input type="email" value="malicious-email@example.com">\n</form>\n\n<script>\n  document.forms[0].submit();\n<\/script>\n'})}),"\n",(0,s.jsx)(t.h3,{id:"preventing-csrf-requests",children:"Preventing CSRF Requests"}),"\n",(0,s.jsx)(t.p,{children:'You can generate CSRF "token" for each active user session managed by the application.\nThis token is used to verify that the authenticated user is the person actually making\nthe requests to the application. Since this token is stored in the user\'s session\nand changes each time the session is regenerated, a malicious application is unable to access it.'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:'<?php\nsession_start();\nif (empty($_SESSION[\'token\'])) {\n    $_SESSION[\'token\'] = bin2hex(random_bytes(32));\n}\n$token = $_SESSION[\'token\'];\n?>\n<form action="https://your-application.com/user/email" method="POST">\n  <input type="email" value="malicious-email@example.com">\n  <input type="hidden" name="token" value="<?php echo $token ?>" />\n</form>\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Anytime you define an HTML form in your application,\nyou should include a hidden CSRF ",(0,s.jsx)(t.code,{children:"_token"})," field in the\nform so that the CSRF protection can validate the request."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"if (!empty($_POST['token'])) {\n    if (hash_equals($_SESSION['token'], $_POST['token'])) {\n         // Proceed to process the form data\n    } else {\n         // Log this as a warning and keep an eye on these attempts\n    }\n}\n"})}),"\n",(0,s.jsx)(t.h3,{id:"per-form-tokens",children:"Per-Form Tokens"}),"\n",(0,s.jsx)(t.p,{children:"You can go even further and generate Per-Form Tokens for every single\nform on your application:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"<?php $second_token = hash_hmac('sha256', '/my_form.php', $_SESSION['second_token']); ?>\n<input type=\"hidden\" name=\"token\" value=\"<?php echo $second_token ?>\" />\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-php",children:"<?php\n$calc = hash_hmac('sha256', '/my_form.php', $_SESSION['second_token']);\nif (hash_equals($calc, $_POST['token'])) {\n    // Continue...\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"You can also change the name of the token variable or invalidate a token\nperiodically in time. If you have a security requirement that each CSRF\ntoken is allowed to be usable exactly once, the simplest strategy\nis to regenerate it after each successful validation.\nHowever, doing so will invalidate every previous token which doesn't\nmix well with people who browse multiple tabs at once."}),"\n",(0,s.jsx)(t.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",children:"Cross-site request forgeries"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://laravel.com/docs/8.x/csrf#csrf-explanation",children:"CSRF Protection with Laravel"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"https://symfony.com/doc/current/security/csrf.html",children:"CSRF Protection with Symfony"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.a,{href:"http://expressjs.com/en/resources/middleware/csurf.html",children:"CSRF Protection with Express.js"})}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);